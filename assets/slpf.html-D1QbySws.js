import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,e,o}from"./app-D6x_2015.js";const p={};function m(r,s){return o(),n("div",null,[t(" more "),s[0]||(s[0]=e('<h1 id="树链剖分" tabindex="-1"><a class="header-anchor" href="#树链剖分"><span>树链剖分</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>树链剖分是一种将树分割成若干条链的形式，以维护树上路径的信息的方式。</p><p><strong>树链剖分</strong>（树剖/链剖）有多种形式，如 <strong>重链剖分</strong>，<strong>长链剖分</strong> 和用于 Link/cut Tree 的剖分（有时被称作 <strong>实链剖分</strong>），大多数情况下（没有特别说明时），<strong>树链剖分</strong> 都指 <strong>重链剖分</strong>。</p><p>重链剖分可以将树上的任意一条路径划分成不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。</p><p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。</p><p>如：路径修改、路径查询、子树修改、子树查询等。</p><p>时间复杂度通常能达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\\log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 甚至结合高级数据结构达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>除了配合数据结构来维护树上路径信息，树剖还可以用来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 求 LCA（常数较小）。在某些题目中，还可以利用其性质来灵活地运用树剖。</p><p>下面给出一些定义：</p><ul><li><strong>重儿子</strong>：对于一个节点 <code>u</code>，它的子节点中<strong>子树大小最大</strong>的那个子节点被称为 <code>u</code> 的重儿子（如果有多个大小相同，任选一个）。<code>u</code> 与它的重儿子之间的边称为**重边。</li><li><strong>轻儿子</strong>：<code>u</code> 的其他子节点称为轻儿子。<code>u</code> 与轻儿子之间的边称为**轻边。</li><li><strong>重链</strong>：由连续的<strong>重边</strong>连接而成的路径称为一条重链。</li><li><strong>轻边</strong>：连接不同重链的桥梁。</li><li><strong>链头</strong>：每条重链的顶端节点（链中深度最小的节点）。</li></ul><h3 id="性质" tabindex="-1"><a class="header-anchor" href="#性质"><span>性质</span></a></h3><p><strong>关键性质</strong>：从树根到任意一个叶子节点的路径上，遇到的<strong>轻边</strong>数量不超过 <code>O(log n)</code> 条。</p><p><strong>证明（直观理解）</strong>：考虑从根节点 <code>root</code> 走到叶子节点 <code>leaf</code>。<br> 每经过一条<strong>轻边</strong> <code>(parent -&gt; child)</code>，意味着 <code>child</code> 不是 <code>parent</code> 的重儿子。<br> 根据重儿子的定义，<code>child</code> 的子树大小 <code>size[child] &lt;= size[parent] / 2</code>（因为重儿子的子树大小至少占一半）。<br> 子树大小每次经过轻边至少减半！树的大小 <code>n</code> 最多能减半 <code>O(log n)</code> 次（从 <code>n</code> 减到 <code>1</code>），所以轻边的数量最多是 <code>O(log n)</code>。<br><strong>推论</strong>：因为一条路径 <code>u -&gt; v</code> 可以看作 <code>u -&gt; LCA(u, v)</code> 和 <code>LCA(u, v) -&gt; v</code> 两条路径的拼接，每条路径最多有 <code>O(log n)</code> 条轻边，那么整条路径最多被拆分成 <code>O(log n)</code> 段重链（因为轻边连接着重链，经过 <code>O(log n)</code> 条轻边就意味着要经过 <code>O(log n)</code> 条重链）。</p>',14))])}const i=a(p,[["render",m]]),g=JSON.parse('{"path":"/oi/tree/slpf.html","title":"树链剖分","lang":"zh-CN","frontmatter":{"date":"2025-06-01T00:00:00.000Z","category":"算法","editLink":false,"comment":false,"contributors":false,"description":"树链剖分 概念 树链剖分是一种将树分割成若干条链的形式，以维护树上路径的信息的方式。 树链剖分（树剖/链剖）有多种形式，如 重链剖分，长链剖分 和用于 Link/cut Tree 的剖分（有时被称作 实链剖分），大多数情况下（没有特别说明时），树链剖分 都指 重链剖分。 重链剖分可以将树上的任意一条路径划分成不超过 logn 条连续的链，每条链上的点深...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"树链剖分\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CJY\\",\\"url\\":\\"https://0xcjy.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://0xcjy.github.io/oi/tree/slpf.html"}],["meta",{"property":"og:site_name","content":"CJY的博客"}],["meta",{"property":"og:title","content":"树链剖分"}],["meta",{"property":"og:description","content":"树链剖分 概念 树链剖分是一种将树分割成若干条链的形式，以维护树上路径的信息的方式。 树链剖分（树剖/链剖）有多种形式，如 重链剖分，长链剖分 和用于 Link/cut Tree 的剖分（有时被称作 实链剖分），大多数情况下（没有特别说明时），树链剖分 都指 重链剖分。 重链剖分可以将树上的任意一条路径划分成不超过 logn 条连续的链，每条链上的点深..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2025-06-01T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.73,"words":818},"filePathRelative":"oi/tree/slpf.md","excerpt":"<!-- more -->\\n<h1>树链剖分</h1>\\n<h2>概念</h2>\\n<p>树链剖分是一种将树分割成若干条链的形式，以维护树上路径的信息的方式。</p>\\n<p><strong>树链剖分</strong>（树剖/链剖）有多种形式，如 <strong>重链剖分</strong>，<strong>长链剖分</strong> 和用于 Link/cut Tree 的剖分（有时被称作 <strong>实链剖分</strong>），大多数情况下（没有特别说明时），<strong>树链剖分</strong> 都指 <strong>重链剖分</strong>。</p>\\n<p>重链剖分可以将树上的任意一条路径划分成不超过 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding=\\"application/x-tex\\">\\\\log n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.8889em;vertical-align:-0.1944em;\\"></span><span class=\\"mop\\">lo<span style=\\"margin-right:0.01389em;\\">g</span></span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">n</span></span></span></span> 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。</p>","autoDesc":true}');export{i as comp,g as data};
